<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Link Organizer</title>
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
    <!-- Sortable.js for drag-and-drop reordering -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <style>
        /* --- Root Variables for Theming --- */
        :root {
            --primary-color: #6366F1;
            /* Indigo 500 */
            --primary-light: #A5B4FC;
            /* Indigo 300 */
            --secondary-color: #06B6D4;
            /* Cyan 500 */
            --error-color: #EF4444;
            /* Archived accent (dark) */
            --archived-accent: #EF4444;

            --bg-color: #0F172A;
            /* Slate 900 */
            --surface-color: #111827;
            /* Gray 900 */
            --text-color: #E5E7EB;
            /* Gray 200 */
            --text-muted-color: #9CA3AF;
            /* Gray 400 */
            --border-color: #1F2937;
            /* Gray 800 */

            --card-shadow: rgba(0, 0, 0, 0.35);
            --modal-shadow: rgba(0, 0, 0, 0.45);
            --input-focus-shadow: rgba(99, 102, 241, 0.35);
            --youtube-thumbnail-border: transparent;
            --three-dots-color: #E5E7EB;
            --three-dots-hover-bg: rgba(255, 255, 255, 0.06);

            --note-add-bg: transparent;
            --note-add-text: var(--text-muted-color);
            --note-open-bg: #0B1220;
            --note-open-text: white;
            --note-open-hover-bg: var(--secondary-color);

            --card-base-width: 320px;
        }

        /* --- Light Theme Class --- */
        body.light-theme {
            --bg-color: #F7F8FA;
            --surface-color: #FFFFFF;
            --text-color: #0F172A;
            --text-muted-color: #64748B;
            /* Slate 500 */
            --border-color: #E5E7EB;
            /* Gray 200 */
            --card-shadow: rgba(15, 23, 42, 0.08);
            --modal-shadow: rgba(15, 23, 42, 0.12);
            --input-focus-shadow: rgba(99, 102, 241, 0.25);
            --youtube-thumbnail-border: var(--border-color);
            --three-dots-color: #0F172A;
            --three-dots-hover-bg: rgba(15, 23, 42, 0.06);
            --archived-accent: #DC2626;
            /* Archived accent (light) */

            --note-add-bg: transparent;
            --note-add-text: var(--text-muted-color);
            --note-open-bg: #0F172A;
            --note-open-text: white;
            --note-open-hover-bg: #0E7490;
            /* Cyan 700 */
        }

        /* --- System Theme (prefers light) --- */
        @media (prefers-color-scheme: light) {
            body:not(.dark-theme):not(.light-theme) {
                --bg-color: #F7F8FA;
                --surface-color: #FFFFFF;
                --text-color: #0F172A;
                --text-muted-color: #64748B;
                --border-color: #E5E7EB;
                --card-shadow: rgba(15, 23, 42, 0.08);
                --modal-shadow: rgba(15, 23, 42, 0.12);
                --input-focus-shadow: rgba(99, 102, 241, 0.25);
                --youtube-thumbnail-border: var(--border-color);
                --three-dots-color: #0F172A;
                --three-dots-hover-bg: rgba(15, 23, 42, 0.06);
                --archived-accent: #DC2626;
                /* Archived accent (system light) */

                --note-add-bg: transparent;
                --note-add-text: var(--text-muted-color);
                --note-open-bg: var(--secondary-color);
                --note-open-text: white;
                --note-open-hover-bg: #0E7490;
            }
        }

        /* --- General Styles --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex;
            min-height: 100vh;
            /* Ensure body takes full height for mobile scroll */
            font-size: 14px;
            /* Base font size */
        }

        /* Scrollbar styles for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--surface-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-light);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-color);
        }

        /* Firefox */
        html {
            scrollbar-color: var(--primary-light) var(--surface-color);
            scrollbar-width: thin;
        }

        /* --- App Layout --- */

        /* Footer toolbar (themes + auth icons in one row) */
        .footer-toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .icon-toggle {
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-color);
            background: var(--bg-color);
            border-radius: 10px;
            cursor: pointer;
            transition: background-color .2s ease, border-color .2s ease, transform .1s ease;
            color: var(--text-color);
        }

        .icon-toggle:hover {
            background-color: var(--three-dots-hover-bg);
            border-color: var(--primary-light);
        }

        .icon-toggle:active {
            transform: scale(.98);
        }

        .icon-toggle.active {
            outline: 2px solid var(--primary-light);
        }

        .footer-spacer {
            flex: 1;
        }

        /* pushes auth icons to right */
        #auth-status {
            gap: 6px;
            padding: 6px 10px;
        }

        /* make chip compact */
        #auth-status span {
            display: none;
        }

        .list-emoji {
            font-size: 1.65em;
            /* bigger emoji */
            line-height: 1;
            /* avoid extra vertical space */
            flex-shrink: 0;
            /* keep size when the row is tight */
        }







        /* hide text, icon-only look */


        /* --- Sidebar actions & list reordering --- */
        .list-actions-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .list-more-btn {
            background: transparent;
            border: 1px solid transparent;
            color: var(--text-muted-color);
            width: 30px;
            height: 30px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color .2s ease, border-color .2s ease, color .2s ease, transform .1s ease;
        }

        .list-more-btn:hover {
            background-color: var(--three-dots-hover-bg);
            border-color: var(--border-color);
            color: var(--text-color);
        }

        .list-more-btn:active {
            transform: scale(.96);
        }


        /* list popover */
        .list-actions-popover {
            position: fixed;
            z-index: 1003;
            display: none;
            min-width: 200px;
            padding: 8px;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            box-shadow: 0 8px 24px var(--card-shadow);
        }

        .list-actions-popover.active {
            display: block;
        }

        .list-actions-popover .menu-item {
            width: 100%;
            display: flex;
            gap: 10px;
            align-items: center;
            border: none;
            background: transparent;
            padding: 10px 12px;
            border-radius: 8px;
            color: var(--text-color);
            cursor: pointer;
            font-size: .95em;
        }

        .list-actions-popover .menu-item:hover {
            background: var(--three-dots-hover-bg);
        }

        .list-actions-popover .menu-item.danger:hover {
            background: rgba(207, 102, 121, .18);
        }

        .sidebar-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .kebab-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            width: 36px;
            height: 36px;
            border-radius: 8px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color .2s ease, border-color .2s ease, transform .1s ease;
        }

        .kebab-btn:hover {
            background-color: var(--three-dots-hover-bg);
            border-color: var(--primary-light);
        }

        .kebab-btn:active {
            transform: scale(.98);
        }

        #list-actions-menu {
            position: absolute;
            top: 48px;
            right: 20px;
            z-index: 1002;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            box-shadow: 0 8px 24px var(--card-shadow);
            padding: 8px;
            display: none;
            min-width: 220px;
        }

        #list-actions-menu.active {
            display: block;
        }

        #list-actions-menu .menu-item {
            width: 100%;
            display: flex;
            gap: 10px;
            align-items: center;
            border: none;
            background: transparent;
            padding: 10px 12px;
            border-radius: 8px;
            color: var(--text-color);
            cursor: pointer;
            font-size: .95em;
        }

        #list-actions-menu .menu-item:hover {
            background: var(--three-dots-hover-bg);
        }

        #list-actions-menu .menu-item.danger:hover {
            background: rgba(207, 102, 121, .18);
        }

        /* Drag handle shown only in reorder mode */
        #lists-container.reorder-active .list-drag-handle {
            display: inline-flex;
        }

        .list-drag-handle {
            display: none;
            margin-right: 8px;
            font-size: 1.1em;
            color: var(--text-muted-color);
            cursor: grab;
            user-select: none;
        }

        /* List item layout tweak to fit drag handle */
        .list-item {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            background: transparent;
            border: 1px solid transparent;
            transition: background-color .2s ease, border-color .2s ease, color .2s ease;
            text-align: left;
            color: var(--text-color);


        }

        .list-label {
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }


        /* Auth icon chips */
        .auth-chip {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background: var(--bg-color);
        }

        .auth-icon {
            width: 20px;
            height: 20px;
            display: inline-block;
        }

        .app-container {
            display: flex;
            width: 100%;
            height: 100vh;
            /* Fixed height to viewport height */
            overflow: hidden;
            /* Hide overflow for the container, let children manage their scroll */
        }

        /* --- Sidebar --- */

        /* Ensure list items (buttons) render with our border/background cleanly */
        .list-item {
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }


        /* Drop target highlight for lists when dragging a video card */
        /* Stronger drop target highlight (beats :hover / .active) */
        .list-item.drop-hover,
        .list-item.drop-hover:hover,
        .list-item.drop-hover.active {
            background: rgba(99, 102, 241, 0.18) !important;
            border-color: var(--primary-light) !important;
            box-shadow: inset 0 0 0 2px var(--primary-light) !important;
        }

        /* Subtle global cue while dragging a video */
        body.dragging-video .sidebar {
            box-shadow: inset 0 0 0 2px var(--primary-light);
        }

        .sidebar {
            width: 280px;
            min-width: 250px;
            background-color: var(--surface-color);
            box-shadow: 2px 0 8px var(--card-shadow);
            padding: 20px;
            display: flex;
            flex-direction: column;
            z-index: 101;
            height: auto;
            /* Changed height as requested */
            overflow-y: hidden;
            /* Prevent sidebar itself from scrolling */
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            color: var(--primary-color);
        }

        .sidebar-header h2 {
            margin: 0;
            font-size: 1.5em;
        }

        .icon-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.8em;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }

        .icon-btn:hover {
            background-color: var(--primary-light);
            transform: scale(1.05);
        }

        .icon-btn:active {
            transform: scale(0.98);
        }

        .lists-container {
            flex-grow: 1;
            /* Allow it to take available height */
            overflow-y: auto;
            /* Make only the lists-container scrollable */
            margin-bottom: 20px;
        }


        /* Hover state for non-active list items */
        .list-item:hover:not(.active) {
            background-color: var(--surface-color);
            border-color: var(--border-color);
            color: var(--text-color);
        }


        /* Active list item styles */
        .list-item.active {
            background: rgba(99, 102, 241, 0.12);
            /* subtle indigo tint */
            border-color: var(--primary-light);
            color: var(--text-color);
            font-weight: 600;
        }

        /* Temporary archived list look */
        .list-item.temp-archived {
            border-color: var(--archived-accent);
            box-shadow: inset 3px 0 0 var(--archived-accent);
        }

        .list-item.temp-archived.active {
            background: rgba(239, 68, 68, 0.12);
            /* dark default */
        }

        body.light-theme .list-item.temp-archived.active,
        @media (prefers-color-scheme: light) {
            body:not(.dark-theme):not(.light-theme) .list-item.temp-archived.active {
                background: rgba(220, 38, 38, 0.10);
                /* light */
            }
        }

        /* Hover state for active list item */
        .list-item.active:hover {
            background: rgba(99, 102, 241, 0.18);
        }

        .user-popover {
            position: fixed;
            z-index: 1003;
            min-width: 240px;
            padding: 12px;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            box-shadow: 0 8px 24px var(--card-shadow);
            display: none;
        }

        .user-popover.active {
            display: block;
        }

        .user-popover .row {
            margin: 6px 0;
            font-size: 0.92em;
            color: var(--text-muted-color);
        }

        .user-popover .name {
            font-weight: 600;
            color: var(--text-color);
        }

        .user-popover .actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 10px;
        }


        .sidebar-footer {
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: auto;
        }

        /* Styles for authentication section */
        .auth-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px dashed var(--border-color);
            align-items: center;
        }

        .auth-controls span {
            font-size: 0.9em;
            color: var(--text-muted-color);
            text-align: center;
        }

        .auth-controls button {
            width: 100%;
            /* Make auth buttons take full width */
            box-sizing: border-box;
            font-weight: normal;
            /* Override bold for general buttons */
        }

        /* Specific style for Google Sign-in button */
        #sign-in-google-btn {
            background-color: #4285F4;
            /* Google Blue */
            border-color: #4285F4;
            color: white;
        }

        #sign-in-google-btn:hover {
            background-color: #357ae8;
            border-color: #357ae8;
        }

        /* End Auth Styles */


        .theme-selector label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: var(--text-muted-color);
        }

        /* --- Main Content Area --- */
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            /* This element itself can scroll if its content overflows */
        }

        header {
            background-color: var(--surface-color);
            padding: 15px 25px;
            box-shadow: 0 2px 5px var(--card-shadow);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
            z-index: 100;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        header h1 {
            margin: 0;
            font-size: 1.8em;
            color: var(--primary-color);
            text-shadow: 0 0 5px rgba(98, 0, 238, 0.3);
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .size-slider-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .size-slider-group label {
            font-size: 0.9em;
            color: var(--text-muted-color);
            white-space: nowrap;
        }

        #card-size-slider {
            width: 120px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--border-color);
            outline: none;
            border-radius: 5px;
            height: 5px;
            cursor: pointer;
        }

        #card-size-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: var(--primary-light);
            cursor: grab;
            transition: background 0.2s ease, transform 0.2s ease;
        }

        #card-size-slider::-webkit-slider-thumb:active {
            transform: scale(1.2);
            cursor: grabbing;
        }

        #card-size-slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: var(--primary-light);
            cursor: grab;
            transition: background 0.2s ease, transform 0.2s ease;
        }

        #card-size-slider::-moz-range-thumb:active {
            transform: scale(1.2);
            cursor: grabbing;
        }


        select,
        button,
        input[type="text"],
        textarea {
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color);
            color: var(--text-color);
            font-size: 0.9em;
            transition: all 0.3s ease;
            outline: none;
        }

        select:focus,
        input[type="text"]:focus,
        textarea:focus {
            border-color: var(--secondary-color);
            box-shadow: 0 0 8px var(--input-focus-shadow);
        }

        button {
            cursor: pointer;
            background-color: var(--primary-color);
            border-color: var(--primary-color);
            font-weight: bold;
            color: white;
        }

        button:hover {
            background-color: var(--primary-light);
            border-color: var(--primary-light);
            color: white;
            /* Keep white for primary light */
        }

        button.outline {
            background-color: transparent;
            border: 1px solid var(--primary-light);
            color: var(--primary-light);
        }

        button.outline:hover {
            background-color: var(--primary-light);
            color: white;
            /* Keep white for outline hover */
        }

        button.danger {
            background-color: var(--error-color);
            border-color: var(--error-color);
            color: var(--text-light);
        }

        button.danger:hover {
            background-color: #b00020;
        }

        main {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            /* This element itself can scroll if its content overflows */
        }

        /* --- Video Grid Container (CSS Grid) --- */
        #video-grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(var(--card-base-width), 1fr));
            gap: 20px;
            justify-items: center;
            align-items: start;
            padding: 10px;
            box-sizing: border-box;
            min-height: 100%;
        }

        /* --- Individual Video Card (YouTube-like) --- */
        .video-card {
            background-color: var(--surface-color);
            border-radius: 8px;
            box-shadow: 0 4px 10px var(--card-shadow);
            overflow: hidden;
            width: 100%;
            /* Take full width of grid cell */
            max-width: var(--card-base-width);
            /* Restrict max width */
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: box-shadow 0.2s ease, transform 0.1s ease, background-color 0.3s ease;
            list-style: none;
            margin: 0;
        }

        .video-card:hover {
            box-shadow: 0 6px 15px var(--card-shadow);
        }

        /* Sortable.js specific classes */
        .video-card.sortable-ghost {
            opacity: 0.2;
            border: 1px dashed var(--primary-light);
            background-color: transparent;
            box-shadow: none;
        }

        .video-card.sortable-drag {
            opacity: 1;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            transform: scale(1.02);
            cursor: grabbing;
        }

        .video-card-thumbnail {
            position: relative;
            /* Crucial for absolute positioning of action buttons */
            width: 100%;
            padding-bottom: 56.25%;
            /* 16:9 Aspect Ratio */
            overflow: hidden;
            border-bottom: 1px solid var(--youtube-thumbnail-border);
            cursor: grab;
            /* Enable drag on thumbnail */
        }

        .video-card-thumbnail img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
        }

        .duration-overlay {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 0.75em;
            padding: 2px 6px;
            border-radius: 4px;
            z-index: 1;
        }

        /* --- Action Buttons (Note & Three Dots) --- */
        .video-card-action-buttons {
            position: absolute;
            /* Position relative to .video-card-thumbnail */
            top: 8px;
            /* Padding from top */
            right: 8px;
            /* Padding from right */
            z-index: 2;
            /* Ensure it's above thumbnail content */
            display: flex;
            flex-direction: column;
            /* Stack vertically */
            align-items: flex-end;
            /* Align icons to the right within their column */
            gap: 5px;
            /* Space between the two icon buttons */

            opacity: 0;
            /* Hidden by default */
            visibility: hidden;
            /* Hidden by default */
            transition: opacity 0.2s ease, visibility 0.2s ease;
            /* Smooth fade */
        }

        /* Show action buttons on hover over the entire video card */
        .video-card:hover .video-card-action-buttons {
            opacity: 1;
            visibility: visible;
        }

        /* Always show action buttons if the video card has a note */
        .video-card.has-note .video-card-action-buttons {
            opacity: 1;
            visibility: visible;
        }


        /* --- Video Card Info Wrapper (Below thumbnail) --- */
        .video-card-info-wrapper {
            display: flex;
            padding: 12px;
            align-items: flex-start;
            gap: 10px;
            position: relative;
            /* For 3-dots menu overlay positioning */
        }

        .channel-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
            margin-top: 2px;
            background-color: var(--border-color);
        }

        .video-text-content {
            flex-grow: 1;
            overflow: hidden;
            min-width: 0;
            /* Important for flex items */
            display: flex;
            /* Made flex to stack children */
            flex-direction: column;
            /* Stack children vertically */
        }

        .video-text-content h3 {
            font-size: 0.95em;
            /* smaller */
            font-weight: 500;
            /* or 400 for normal weight */
            margin: 0 0 3px;
            line-height: 1.25;
            max-height: 2.5em;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            color: var(--text-color);
        }

        .video-card-meta {
            line-height: 1.3;
            /* Adjust line height for meta info */
        }

        .video-card-meta p {
            margin: 0;
            font-size: 0.85em;
            color: var(--text-muted-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .video-card-meta p.channel-name {
            font-weight: 500;
            color: var(--text-muted-color);
        }

        /* --- Inline Note Button (Icon Only) --- */
        .inline-note-btn {
            font-family: 'Segoe UI Emoji', 'Noto Color Emoji', 'Apple Color Emoji', sans-serif;
            /* Ensure emoji renders */
            font-size: 1.5em;
            /* Larger for icon */
            width: 32px;
            /* Fixed width for square button */
            height: 32px;
            /* Fixed height for square button */
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            /* Remove padding for icon button */
            border-radius: 25%;
            /* Changed from 50% to 25% */
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
            box-sizing: border-box;
        }

        /* "Add Note" button (no note) - simple white and black formatting */
        .inline-note-btn.add-note {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted-color);
        }

        .inline-note-btn.add-note:hover {
            background-color: var(--three-dots-hover-bg);
            color: var(--text-color);
            border-color: var(--text-color);
        }

        /* "Open Note" button (has note) - colored */
        .inline-note-btn.open-note {
            background-color: var(--note-open-bg);
            /* Solid teal */
            border: 1px solid var(--secondary-color);
            color: var(--note-open-text);
            /* White icon */
        }

        .inline-note-btn.open-note:hover {
            background-color: var(--note-open-hover-bg);
            /* Darker solid teal */
            color: var(--note-open-text);
        }

        /* --- Three-dot menu button --- */
        .three-dots-menu-btn {
            background: none;
            border: none;
            color: var(--three-dots-color);
            font-size: 1.5em;
            width: 24px;
            height: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            /* Margins removed, controlled by parent .video-card-action-buttons gap/flex */
            cursor: pointer;
            border-radius: 50%;
            transition: background-color 0.2s ease, color 0.2s ease;
            /* Added color transition */
            flex-shrink: 0;
            position: relative;
        }

        .three-dots-menu-btn:hover {
            background-color: var(--three-dots-hover-bg);
            color: var(--text-color);
        }

        /* Specific hover for light theme to ensure dark text on light hover */
        body.light-theme .three-dots-menu-btn:hover,
        @media (prefers-color-scheme: light) {
            body:not(.dark-theme):not(.light-theme) .three-dots-menu-btn:hover {
                background-color: var(--border-color);
                /* Lighter border for light theme hover */
                color: var(--text-color);
                /* Dark text on light hover */
            }
        }

        .three-dots-menu-btn:focus {
            outline: 2px solid var(--primary-light);
        }


        .video-menu-overlay {
            position: fixed;
            background-color: var(--surface-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--card-shadow);
            z-index: 1000;
            min-width: 150px;
            padding: 8px 0;
            display: none;
            flex-direction: column;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s ease;
        }

        .video-menu-overlay.active {
            display: flex;
            opacity: 1;
            visibility: visible;
        }

        .video-menu-overlay button.menu-item {
            display: block;
            width: 100%;
            text-align: left;
            padding: 10px 15px;
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 0.9em;
            cursor: pointer;
            border-radius: 0;
            transition: background-color 0.2s ease;
        }

        .video-menu-overlay button.menu-item:hover {
            background-color: var(--three-dots-hover-bg);
        }

        .video-menu-overlay button.menu-item.danger:hover {
            background: rgba(207, 102, 121, 0.18);
            /* matches your --error-color tone */
        }

        /* --- Modals --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--surface-color);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px var(--modal-shadow);
            width: 90%;
            max-width: 500px;
            transform: translateY(-20px);
            transition: transform 0.3s ease, background-color 0.3s ease;
            color: var(--text-color);
            position: relative;
            /* For the close button */
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
        }

        .modal-content h2 {
            margin-top: 0;
            color: var(--primary-color);
            font-size: 1.5em;
            text-align: center;
            margin-bottom: 20px;
        }

        .modal-content label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-color);
            font-weight: bold;
        }

        .modal-content input[type="text"],
        .modal-content textarea {
            width: calc(100% - 24px);
            /* Account for padding */
            margin-bottom: 15px;
        }

        .modal-content textarea {
            min-height: 120px;
            resize: vertical;
        }

        .modal-content .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-content .modal-actions button {
            min-width: 90px;
        }

        /* Close button for modals */
        .modal-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: var(--text-muted-color);
            cursor: pointer;
            transition: color 0.2s ease;
            padding: 5px;
            line-height: 1;
        }

        .modal-close-btn:hover {
            color: var(--primary-color);
        }

        /* --- Note Modal Video Preview (New) --- */
        .note-modal-video-preview {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: flex-start;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--bg-color);
            /* Slightly different from modal surface */
        }

        .note-modal-video-preview-thumbnail {
            width: 120px;
            /* Fixed small width */
            height: 67.5px;
            /* 16:9 aspect ratio for 120px width */
            flex-shrink: 0;
            overflow: hidden;
            border-radius: 4px;
            position: relative;
            /* For duration overlay */
        }

        .note-modal-video-preview-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .note-modal-video-preview-thumbnail .duration-overlay {
            /* Inherit existing duration-overlay styles */
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 0.65em;
            padding: 1px 4px;
        }

        .note-modal-video-preview-info {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            /* Important for flex-grow to work */
        }

        .note-modal-video-preview-info h3 {
            font-size: 1.1em;
            margin: 0 0 5px;
            line-height: 1.3;
            max-height: 2.6em;
            /* 2 lines */
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            color: var(--text-color);
        }

        .note-modal-video-preview-info p {
            font-size: 0.8em;
            color: var(--text-muted-color);
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* End Note Modal Video Preview */


        /* --- Messages and Loading --- */
        #message-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 300px;
            pointer-events: none;
        }

        .message {
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 0.9em;
            opacity: 0;
            transform: translateX(100%);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
        }

        .message.show {
            opacity: 1;
            transform: translateX(0);
        }

        .message.success {
            background-color: #4CAF50;
            color: white;
        }

        .message.error {
            background-color: var(--error-color);
            color: white;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .loading-overlay.active {
            display: flex;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid var(--primary-light);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* --- Media Queries for Responsiveness --- */
        @media (max-width: 992px) {
            .sidebar {
                width: 200px;
                min-width: 180px;
                padding: 15px;
            }

            .sidebar-header h2 {
                font-size: 1.3em;
            }

            .list-item {
                font-size: 1em;
                padding: 10px 12px;
            }

            header h1 {
                font-size: 1.5em;
            }

            .controls {
                gap: 8px;
            }

            select,
            button,
            input[type="text"] {
                padding: 8px 12px;
                font-size: 0.85em;
            }

            .video-text-content h3 {
                font-size: 1em;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
                height: auto;
                overflow: visible;
            }

            body {
                min-height: 100vh;
            }

            .sidebar {
                width: 100%;
                height: auto;
                max-height: 180px;
                padding: 15px 20px;
                box-shadow: 0 2px 5px var(--card-shadow);
                order: -1;
                border-bottom-left-radius: 0;
                border-bottom-right-radius: 0;
                overflow-y: hidden;
            }

            .lists-container {
                overflow-y: auto;
            }

            .sidebar-header {
                justify-content: center;
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 1px solid var(--border-color);
                position: relative;
            }

            .sidebar-header h2 {
                flex-grow: 1;
                text-align: center;
            }

            .icon-btn {
                position: absolute;
                right: 20px;
                top: 10px;
                width: 36px;
                height: 36px;
                font-size: 1.5em;
            }

            .lists-container {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                justify-content: center;
                margin-bottom: 15px;
            }

            .list-item {
                width: auto;
                margin-bottom: 0;
                padding: 8px 15px;
                font-size: 0.9em;
                flex-shrink: 0;
            }

            .sidebar-footer {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                padding-top: 15px;
                margin-top: 0;
            }

            .sidebar-footer button.danger {
                order: 2;
            }

            .theme-selector {
                order: 1;
            }

            .main-content {
                width: 100%;
            }

            header {
                padding: 10px;
                flex-direction: column;
                align-items: flex-start;
                border-top-left-radius: 0;
                border-top-right-radius: 0;
            }

            .controls {
                width: 100%;
                justify-content: center;
                gap: 5px;
            }

            .size-slider-group {
                width: 100%;
                justify-content: center;
            }

            #message-container {
                top: unset;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 350px;
                text-align: center;
            }

            #video-grid-container {
                padding: 10px;
            }

            .video-card {
                max-width: 100%;
            }

            .video-card-thumbnail {
                cursor: pointer;
            }

            .video-card.sortable-drag {
                cursor: grabbing;
            }

            /* Action buttons row on small screens */
            .video-card-action-buttons {
                flex-direction: row;
                justify-content: flex-end;
                gap: 8px;
                width: auto;
                top: 5px;
                right: 5px;
            }
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header" style="position:relative;">
                <h2>Your Lists</h2>
                <div class="sidebar-actions">
                    <button id="create-list-btn" class="icon-btn" title="Create New List">+</button>
                </div>


            </div>

            <div id="lists-container" class="lists-container">
                <!-- Lists will be dynamically rendered here -->
            </div>
            <div class="sidebar-footer">
                <!-- Authentication Controls -->
                <div class="footer-toolbar">
                    <!-- Theme icon buttons -->
                    <button id="theme-toggle-btn" class="icon-toggle" title="Theme" aria-label="Theme">🖥️</button>
                    <button id="archive-lists-btn" class="icon-toggle" title="Archived Lists"
                        aria-label="Archived Lists">🗃️</button>

                    <div class="footer-spacer"></div>

                    <!-- Small user chip (icon-only) + auth buttons as icons -->
                    <span id="auth-status" class="auth-chip" title="Auth status">
                        <svg class="auth-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                            <path
                                d="M12 12a5 5 0 1 0-5-5 5 5 0 0 0 5 5zm0 2c-4.33 0-8 2.17-8 5v1h16v-1c0-2.83-3.67-5-8-5z" />
                        </svg>
                        <span>…</span>
                    </span>

                    <button id="sign-in-google-btn" class="icon-toggle" style="display:none;"
                        title="Sign in with Google" aria-label="Sign in with Google">🔑</button>
                </div>

            </div>
        </aside>

        <!-- Main Content -->
        <div class="main-content">
            <header>
                <h1>YouTube Link Organizer</h1>
                <div class="controls">
                    <input type="text" id="search-input" placeholder="Search videos...">
                    <div class="size-slider-group">
                        <label for="card-size-slider">Card Size:</label>
                        <input type="range" id="card-size-slider" min="250" max="450" value="320">
                    </div>
                    <button id="add-video-button-header" title="Add Video">➕ Add Video</button>
                </div>
            </header>

            <main>
                <div id="video-grid-container">
                    <!-- Video cards will be dynamically loaded here -->
                </div>
            </main>
        </div>
    </div>

    <!-- Modals -->
    <div id="add-video-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn cancel-btn" title="Close">&times;</button>
            <h2>Add New YouTube Video</h2>
            <label for="video-link-input">YouTube Video URL:</label>
            <input type="text" id="video-link-input" placeholder="e.g., https://www.youtube.com/watch?v=dQw4w9WgXcQ">
            <div class="modal-actions">
                <button class="outline cancel-btn">Cancel</button>
                <button id="submit-video-btn">Add Video</button>
            </div>
        </div>
    </div>

    <div id="create-list-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn cancel-btn" title="Close">&times;</button>
            <h2>Create New List</h2>
            <label for="list-name-input">List Name:</label>
            <input type="text" id="list-name-input" placeholder="e.g., My Favorites, Tutorials">
            <div class="modal-actions">
                <button class="outline cancel-btn">Cancel</button>
                <button id="submit-list-btn">Create List</button>
            </div>
        </div>
    </div>

    <!-- NEW: Confirm Archive Modal -->
    <div id="confirm-archive-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn cancel-btn" title="Close">&times;</button>
            <h2>Archive List</h2>
            <p id="confirm-archive-message">Are you sure you want to archive this list?</p>
            <div class="modal-actions">
                <button class="outline cancel-btn">Cancel</button>
                <button id="confirm-archive-btn">Archive</button>
            </div>
        </div>
    </div>

    <!-- NEW: Archived Lists Modal -->
    <div id="archived-lists-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn cancel-btn" title="Close">&times;</button>
            <h2>Archived Lists</h2>
            <div id="archived-lists-container" style="max-height:300px; overflow:auto;"></div>
            <div class="modal-actions">
                <button class="outline cancel-btn">Close</button>
            </div>
        </div>
    </div>

    <div id="confirm-delete-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn cancel-btn" title="Close">&times;</button>
            <h2>Confirm Deletion</h2>
            <p id="confirm-delete-message">Are you sure you want to delete this item?</p>
            <div class="modal-actions">
                <button class="outline cancel-btn">Cancel</button>
                <button id="confirm-delete-btn" class="danger">Delete</button>
            </div>
        </div>
    </div>

    <div id="rename-list-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn cancel-btn" title="Close">&times;</button>
            <h2>Rename List</h2>
            <label for="rename-list-name-input">New List Name:</label>
            <input type="text" id="rename-list-name-input" placeholder="Enter new list name">
            <div class="modal-actions">
                <button class="outline cancel-btn">Cancel</button>
                <button id="submit-rename-list-btn">Rename</button>
            </div>
        </div>
    </div>

    <!-- New Note Edit Modal -->
    <div id="note-edit-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn cancel-btn" title="Close">&times;</button>
            <h2 id="note-modal-title">Edit Note</h2>
            <!-- Video Preview section within the note modal -->
            <div id="note-video-details" class="note-modal-video-preview">
                <!-- Video details will be dynamically loaded here -->
            </div>
            <label for="note-textarea-modal">Note Content:</label>
            <textarea id="note-textarea-modal" placeholder="Type your notes here..."></textarea>
            <div class="modal-actions">
                <button class="outline cancel-btn">Cancel</button>
                <button id="delete-note-btn-modal" class="danger">Delete Note</button>
                <button id="save-note-btn-modal">Save Note</button>
            </div>
        </div>
    </div>

    <!-- Message Container -->
    <div id="message-container"></div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="spinner"></div>
    </div>

    <script>
        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyAU-lbB1xDIds2tqo8tjnqDdUDq6rbDVm8",
            authDomain: "alamza-a77a9.firebaseapp.com",
            databaseURL: "https://alamza-a77a9-default-rtdb.firebaseio.com",
            projectId: "alamza-a77a9",
            storageBucket: "alamza-a77a9.firebasestorage.app",
            messagingSenderId: "815562116019",
            appId: "1:815562116019:web:09b325349a2d336b2f19c6",
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();
        const auth = firebase.auth();

        // --- YouTube API Configuration ---
        const YOUTUBE_API_KEY = 'AIzaSyAi9TmRbAeBiTxzxtUGoDiyVHOhW63GYNc';

        // --- DOM Elements ---
        const videoGridContainer = document.getElementById('video-grid-container');
        const addVideoButtonHeader = document.getElementById('add-video-button-header');
        const addVideoModal = document.getElementById('add-video-modal');
        const videoLinkInput = document.getElementById('video-link-input');
        const submitVideoBtn = document.getElementById('submit-video-btn');

        const listsContainer = document.getElementById('lists-container');
        const createListBtn = document.getElementById('create-list-btn');
        const createListModal = document.getElementById('create-list-modal');
        const listNameInput = document.getElementById('list-name-input');
        const submitListBtn = document.getElementById('submit-list-btn');

        const confirmDeleteModal = document.getElementById('confirm-delete-modal');
        const confirmDeleteMessage = document.getElementById('confirm-delete-message');
        const confirmDeleteBtn = document.getElementById('confirm-delete-btn');

        const confirmArchiveModal = document.getElementById('confirm-archive-modal');
        const confirmArchiveMessage = document.getElementById('confirm-archive-message');
        const confirmArchiveBtn = document.getElementById('confirm-archive-btn');

        const archivedListsModal = document.getElementById('archived-lists-modal');
        const archivedListsContainer = document.getElementById('archived-lists-container');
        const archiveListsBtn = document.getElementById('archive-lists-btn');

        const renameListModal = document.getElementById('rename-list-modal'); // New
        const renameListNameInput = document.getElementById('rename-list-name-input'); // New
        const submitRenameListBtn = document.getElementById('submit-rename-list-btn'); // New

        const searchInput = document.getElementById('search-input');
        const messageContainer = document.getElementById('message-container');
        const loadingOverlay = document.getElementById('loading-overlay');

        const cardSizeSlider = document.getElementById('card-size-slider');

        // Note Modal Elements
        const noteEditModal = document.getElementById('note-edit-modal');
        const noteModalTitle = document.getElementById('note-modal-title');
        const noteVideoDetails = document.getElementById('note-video-details');
        const noteTextareaModal = document.getElementById('note-textarea-modal');
        const saveNoteBtnModal = document.getElementById('save-note-btn-modal');
        const deleteNoteBtnModal = document.getElementById('delete-note-btn-modal');

        // Authentication DOM elements (NEW)
        const authStatusSpan = document.getElementById('auth-status');
        const signInGoogleBtn = document.getElementById('sign-in-google-btn');


        // --- Global State Variables ---
        let currentUserId = null;
        let currentListId = null;
        let currentListName = null;
        let videoCards = {}; // Stores { videoId: { element: DOM_Element, data: Object } }
        let sortableInstance = null;
        let currentMenu = null; // To store the currently open 3-dots menu element
        let currentNoteVideoId = null; // To track which video's note is being edited
        let listsSortable = null;
        let listSortMode = false;
        let archivedLists = [];
        let tempArchivedListId = null;
        let tempArchivedListName = null;
        let isDraggingVideo = false;
        let currentDragPayload = null;



        // --- Utility Functions ---
        function stripLeadingEmoji(name = '') {
            // if name starts with emoji + space, remove it from label to avoid double-emoji
            // simple heuristic: if first char is surrogate pair or in emoji range
            const m = name.match(/^(\p{Emoji_Presentation}|\p{Extended_Pictographic})\s+/u);
            return m ? name.slice(m[0].length) : name;
        }
        function getListEmoji(name = '') {
            const m = name.match(/^(\p{Emoji_Presentation}|\p{Extended_Pictographic})/u);
            if (m) return m[1];
            const n = name.toLowerCase();
            if (n.includes('fav')) return '⭐';
            if (n.includes('tutorial')) return '📘';
            if (n.includes('music')) return '🎵';
            if (n.includes('watch')) return '⏱️';
            return '📂';
        }


        function showMessage(text, type = 'info', duration = 3000) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', type);
            messageDiv.textContent = text;
            messageContainer.appendChild(messageDiv);

            setTimeout(() => messageDiv.classList.add('show'), 10);

            setTimeout(() => {
                messageDiv.classList.remove('show');
                messageDiv.addEventListener('transitionend', () => messageDiv.remove());
            }, duration);
        }

        function showLoading() {
            loadingOverlay.classList.add('active');
        }

        function hideLoading() {
            loadingOverlay.classList.remove('active');
        }

        function showModal(modalElement) {
            modalElement.classList.add('active');
            // Add event listener to close on escape key
            document.addEventListener('keydown', handleEscapeKey);
        }

        function hideModal(modalElement) {
            modalElement.classList.remove('active');
            // Remove event listener
            document.removeEventListener('keydown', handleEscapeKey);
        }

        function handleEscapeKey(e) {
            if (e.key === 'Escape') {
                const activeModals = document.querySelectorAll('.modal-overlay.active');
                if (activeModals.length > 0) {
                    // Close the topmost active modal
                    hideModal(activeModals[activeModals.length - 1]);
                }
            }
        }

        function debounce(func, delay) {
            let timeout;
            return function (...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        // --- Theme Management ---
        const LOCAL_STORAGE_THEME_KEY = 'youtube_organizer_theme';
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        let mediaQueryList = null;

        function updateThemeToggleIcon(theme) {
            if (!themeToggleBtn) return;
            const map = { system: '🖥️', dark: '🌙', light: '☀️' };
            themeToggleBtn.textContent = map[theme] || '🖥️';
            themeToggleBtn.title = `Theme: ${theme}`;
            themeToggleBtn.setAttribute('aria-label', `Theme: ${theme}`);
        }


        function handleSystemThemeChange(e) {
            // Only react if the current mode is 'system'
            if ((localStorage.getItem(LOCAL_STORAGE_THEME_KEY) || 'system') === 'system') {
                document.body.classList.toggle('light-theme', e.matches);
                document.body.classList.toggle('dark-theme', !e.matches);
            }
        }

        function applyTheme(theme) {
            document.body.classList.remove('light-theme', 'dark-theme');

            // Detach previous system listener
            if (mediaQueryList) {
                mediaQueryList.removeEventListener('change', handleSystemThemeChange);
                mediaQueryList = null;
            }

            if (theme === 'light') {
                document.body.classList.add('light-theme');
            } else if (theme === 'dark') {
                document.body.classList.add('dark-theme');
            } else { // 'system'
                mediaQueryList = window.matchMedia('(prefers-color-scheme: light)');
                mediaQueryList.addEventListener('change', handleSystemThemeChange);
                handleSystemThemeChange(mediaQueryList); // set initial
            }

            localStorage.setItem(LOCAL_STORAGE_THEME_KEY, theme);
            updateThemeToggleIcon(theme);
        }

        // Initialize theme on page load
        applyTheme(localStorage.getItem(LOCAL_STORAGE_THEME_KEY) || 'system');

        // Hook up the icon buttons
        function cycleTheme() {
            const current = localStorage.getItem(LOCAL_STORAGE_THEME_KEY) || 'system';
            const sysLight = window.matchMedia('(prefers-color-scheme: light)').matches;
            const oppositeOfSystem = sysLight ? 'dark' : 'light';
            const lastOne = sysLight ? 'light' : 'dark';
            const order = ['system', oppositeOfSystem, lastOne];
            const next = order[(order.indexOf(current) + 1) % order.length];
            applyTheme(next);
        }
        if (themeToggleBtn) themeToggleBtn.addEventListener('click', cycleTheme);
        // Hook up the icon buttons to cycle through themes
        // --- End Theme Management ---



        // --- Card Size Management ---
        const LOCAL_STORAGE_CARD_SIZE_KEY = 'youtube_organizer_card_size';

        function applyCardSize(size) {
            document.documentElement.style.setProperty('--card-base-width', `${size}px`);
            localStorage.setItem(LOCAL_STORAGE_CARD_SIZE_KEY, size);
            cardSizeSlider.value = size; // Update slider position
        }

        // Initialize card size on page load
        const savedCardSize = localStorage.getItem(LOCAL_STORAGE_CARD_SIZE_KEY) || cardSizeSlider.value; // Default to slider's HTML value
        applyCardSize(savedCardSize);
        cardSizeSlider.addEventListener('input', (e) => {
            applyCardSize(e.target.value);
        });


        // --- Firebase Authentication ---

        // Ensure auth state is persisted (requires cookies/localStorage)
        auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL).catch((err) => {
            console.warn('Auth persistence error:', err);
            showMessage('Enable cookies/storage for sign-in to work.', 'error', 6000);
        });

        // Warn if running from file:// or an unsupported protocol
        (function () {
            const ok = ['http:', 'https:', 'chrome-extension:'];
            if (!ok.includes(window.location.protocol)) {
                showMessage(`This page is loaded via ${window.location.protocol} — sign-in requires http/https.`, 'error', 8000);
            }
        })();
        auth.onAuthStateChanged(user => {
            // Handle result when returning from signInWithRedirect
            auth.getRedirectResult()
                .then((result) => {
                    if (result && result.user) {
                        showMessage(`Welcome, ${result.user.displayName || result.user.email}!`, 'success', 3000);
                    }
                })
                .catch((error) => {
                    if (error && error.message) {
                        console.error('Redirect sign-in error:', error);
                        showMessage(`Sign-in failed after redirect: ${error.message}`, 'error', 7000);
                    }
                });

            if (user) {
                currentUserId = user.uid;
                console.log("Firebase user logged in:", user.uid);
                {
                    const chipText = authStatusSpan.querySelector('span');
                    if (chipText) chipText.textContent = (user.displayName || user.email || 'Anonymous');
                }
                signInGoogleBtn.style.display = 'none';
                loadLists(); // Load data for the logged-in user
                // Show list related buttons
                createListBtn.style.display = 'inline-flex'; // Assuming this is an icon-btn
            } else {
                currentUserId = null;
                currentListId = null; // Clear selected list
                currentListName = null;
                console.log("No user logged in.");
                {
                    const chipText = authStatusSpan.querySelector('span');
                    if (chipText) chipText.textContent = 'Not logged in';
                } signInGoogleBtn.style.display = 'inline-block'; // Show sign-in button
                closeUserPopover();


                // Clear UI and show messages
                listsContainer.innerHTML = '<p style="text-align: center; color: var(--text-color); padding: 20px;">Please sign in to manage your lists.</p>';
                videoGridContainer.innerHTML = '<p style="text-align: center; color: var(--text-color); grid-column: 1 / -1;">Please sign in to view videos.</p>';

                // Hide list management buttons
                createListBtn.style.display = 'none';

                // Destroy Sortable.js instance if any
                if (sortableInstance) {
                    sortableInstance.destroy();
                    sortableInstance = null;
                }
            }
        });




        // New Google Sign-In Function (popup with smart redirect fallback)
        async function signInWithGoogle() {
            showLoading();
            const provider = new firebase.auth.GoogleAuthProvider();
            try {
                await auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
                const proto = window.location.protocol;
                const canPopup = (proto === 'http:' || proto === 'https:' || proto === 'chrome-extension:');

                if (canPopup) {
                    try {
                        const result = await firebase.auth().signInWithPopup(provider);
                        const user = result.user;
                        if (user) showMessage(`Welcome, ${user.displayName || user.email}!`, 'success', 3000);
                    } catch (popupErr) {
                        // Fallback to redirect for environments blocking popups or not supported
                        if (
                            popupErr?.code === 'auth/popup-blocked' ||
                            popupErr?.code === 'auth/operation-not-supported-in-this-environment' ||
                            popupErr?.code === 'auth/popup-closed-by-user'
                        ) {
                            await firebase.auth().signInWithRedirect(provider);
                            return;
                        }
                        throw popupErr;
                    }
                } else {
                    // Non-supported protocol -> use redirect (still requires http/https at final URL)
                    await firebase.auth().signInWithRedirect(provider);
                    return;
                }
            } catch (error) {
                console.error('Google Sign-in failed:', error);
                showMessage(`Google Sign-in failed: ${error.message}`, 'error', 7000);
            } finally {
                hideLoading();
            }
        }


        // New Sign Out Function
        function signOutUser() {
            showLoading();
            firebase.auth().signOut()
                .then(() => {
                    console.log("User signed out.");
                    showMessage("You have been signed out.", 'success', 2000);
                    // onAuthStateChanged will handle UI updates
                })
                .catch((error) => {
                    console.error("Error signing out:", error);
                    showMessage("Error signing out.", 'error');
                })
                .finally(() => {
                    hideLoading();
                });
        }


        // --- List Management ---
        function loadLists() {
            if (!currentUserId) return;
            showLoading();
            // Detach previous listener to avoid multiple callbacks
            db.ref(`users/${currentUserId}/lists`).off('value');

            db.ref(`users/${currentUserId}/lists`).on('value', snapshot => {
                listsContainer.innerHTML = '';
                document.querySelectorAll('.list-actions-popover').forEach(el => el.remove());
                const lists = snapshot.val();
                let hasLists = false;
                let firstListId = null;

                if (lists) {
                    // build array and sort by 'order' (fallback to name)
                    const listEntries = Object.entries(lists).map(([id, obj]) => ({ id, ...obj }));
                    listEntries.sort((a, b) => {
                        const ao = typeof a.order === 'number' ? a.order : Number.MAX_SAFE_INTEGER;
                        const bo = typeof b.order === 'number' ? b.order : Number.MAX_SAFE_INTEGER;
                        if (ao !== bo) return ao - bo;
                        return (a.name || '').localeCompare(b.name || '');
                    });

                    archivedLists = [];
                    listEntries.forEach(({ id: listId, name, isArchived }) => {
                        if (isArchived) { archivedLists.push({ id: listId, name }); return; }
                        hasLists = true;
                        if (!firstListId) firstListId = listId;

                        const listItem = document.createElement('button');
                        listItem.classList.add('list-item');
                        listItem.setAttribute('data-id', listId);

                        // emoji + drag handle + label + trailing more
                        const emoji = document.createElement('span');
                        emoji.className = 'list-emoji';
                        emoji.textContent = getListEmoji(name);

                        const handle = document.createElement('span');
                        handle.className = 'list-drag-handle';
                        handle.title = 'Drag to reorder';
                        handle.textContent = '⋮⋮';

                        const label = document.createElement('span'); label.className = 'list-label';
                        label.textContent = stripLeadingEmoji(name);

                        const right = document.createElement('div');
                        right.className = 'list-actions-right';
                        const moreBtn = document.createElement('button');
                        moreBtn.className = 'list-more-btn';
                        moreBtn.title = 'List actions';
                        moreBtn.setAttribute('aria-label', 'List actions');
                        moreBtn.textContent = '⋯';
                        right.appendChild(moreBtn);

                        listItem.appendChild(emoji);
                        listItem.appendChild(handle);
                        listItem.appendChild(label);
                        listItem.appendChild(right);
                        // Make sidebar list items act as drop targets for video cards

                        // Drag depth counter to avoid flicker when moving over child nodes
                        let dragDepth = 0;

                        listItem.addEventListener('dragenter', (e) => {
                            if (!isDraggingVideo) return;
                            dragDepth++;
                            listItem.classList.add('drop-hover');
                        });

                        listItem.addEventListener('dragover', (e) => {
                            // Always prevent default so the cursor is not "🚫"
                            e.preventDefault();
                            // Only show move cursor if we are dragging a video
                            e.dataTransfer.dropEffect = isDraggingVideo ? 'move' : 'none';

                            if (isDraggingVideo) {
                                listItem.classList.add('drop-hover');
                            } else {
                                listItem.classList.remove('drop-hover');
                            }
                        });

                        listItem.addEventListener('dragleave', () => {
                            dragDepth = Math.max(0, dragDepth - 1);
                            if (dragDepth === 0) listItem.classList.remove('drop-hover');
                        });

                        listItem.addEventListener('drop', async (e) => {
                            e.preventDefault();
                            dragDepth = 0;
                            listItem.classList.remove('drop-hover');

                            // Prefer live event data, but fall back to the dragstart payload
                            let data = safeParseDragData(e);
                            if (!data) data = currentDragPayload;

                            if (!isDraggingVideo || !data || !data.videoId) return;

                            const { videoId, fromListId } = data;
                            const toListId = listId;

                            if (!currentUserId || !videoId || !fromListId || !toListId) return;
                            if (fromListId === toListId) return;

                            try {
                                await moveVideoBetweenLists(videoId, fromListId, toListId);
                                showMessage(`Moved video to "${stripLeadingEmoji(name || '')}".`, 'success', 2500);
                            } catch (err) {
                                console.error('Drop error:', err);
                                showMessage('Could not move video.', 'error');
                            } finally {
                                // reset guard just in case
                                isDraggingVideo = false;
                                currentDragPayload = null;
                            }
                        });



                        // build a popover for this item
                        const pop = document.createElement('div');
                        pop.className = 'list-actions-popover';
                        pop.innerHTML = `
  <button class="menu-item" data-act="reorder"><span>↕</span><span>${listSortMode ? 'Done Reordering' : 'Reorder Lists'}</span></button>
  <button class="menu-item" data-act="rename"><span>✏️</span><span>Rename Current List</span></button>
  <button class="menu-item" data-act="emoji"><span>😊</span><span>Change List Emoji</span></button>
  <button class="menu-item" data-act="archive"><span>📦</span><span>Archive Current List</span></button>
  <button class="menu-item danger" data-act="delete"><span>🗑️</span><span>Delete Current List</span></button>
`;

                        document.body.appendChild(pop);

                        // open menu, ensure this list is selected
                        moreBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            if (currentListId !== listId) selectList(listId, name);
                            closeAnyListMenus();
                            const r = moreBtn.getBoundingClientRect();
                            let left = Math.min(Math.max(10, r.right - 210), window.innerWidth - 210 - 10);
                            let top = r.bottom + 6;
                            if (top + 160 > window.innerHeight - 10) { top = r.top - 160 - 6; }
                            pop.style.left = left + 'px';
                            pop.style.top = top + 'px';
                            pop.classList.add('active');
                        });

                        // actions
                        pop.addEventListener('click', (e) => {
                            const btn = e.target.closest('.menu-item'); if (!btn) return;
                            const act = btn.dataset.act;
                            if (act === 'reorder') { toggleListReorder(); pop.classList.remove('active'); }
                            if (act === 'rename') { openRenameListModal(); pop.classList.remove('active'); }
                            if (act === 'emoji') { changeCurrentListEmoji(); pop.classList.remove('active'); }
                            if (act === 'archive') { openConfirmArchiveModal(); pop.classList.remove('active'); }
                            if (act === 'delete') { deleteCurrentList(); pop.classList.remove('active'); }
                        });


                        listItem.addEventListener('click', () => selectList(listId, name));
                        listsContainer.appendChild(listItem);
                    });

                    // ensure reorder UI state
                    listsContainer.classList.toggle('reorder-active', listSortMode);
                    initListsSortable();
                    if (tempArchivedListId) { injectTempArchivedListIntoSidebar(); }
                }

                if (!hasLists) {
                    // Automatically create "My Videos" list if no lists exist
                    createNewList('My Videos');
                } else {
                    // Select first list if no current list or current list was deleted
                    if (!currentListId || !lists[currentListId]) {
                        selectList(firstListId, lists[firstListId].name);
                    } else {
                        // Re-select the active list to update its UI state
                        selectList(currentListId, currentListName);
                    }
                }
                updateDeleteListButtonVisibility();
                hideLoading();
            }, error => {
                console.error("Error loading lists:", error);
                showMessage("Failed to load your lists.", 'error');
                hideLoading();
            });
        }
        let videoListenerRef = null;

        function selectList(listId, listName) {
            // agar kisi aur list par jaa rahe ho to temporary archived item hata do
            if (tempArchivedListId && listId !== tempArchivedListId) {
                removeTempArchivedFromSidebar();
            }


            // Only re-render if a different list is selected
            if (currentListId === listId) {
                updateActiveListClass(listId);
                return;
            }

            // Detach old video listener before changing list
            if (currentUserId && currentListId && videoListenerRef) {
                db.ref(`users/${currentUserId}/lists/${currentListId}/videos`).off('value');
            }
            // Destroy Sortable.js instance for old grid
            if (sortableInstance) {
                sortableInstance.destroy();
                sortableInstance = null;
            }

            currentListId = listId;
            currentListName = listName;
            updateActiveListClass(listId);
            updateDeleteListButtonVisibility();
            renderVideos();
        }

        function updateActiveListClass(activeId) {
            document.querySelectorAll('.list-item').forEach(item => {
                if (item.dataset.id === activeId) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        function createNewList(name) {
            if (!currentUserId) return;
            showLoading();
            const newListRef = db.ref(`users/${currentUserId}/lists`).push();
            newListRef.set({
                name: name,
                createdAt: firebase.database.ServerValue.TIMESTAMP
            }).then(() => {
                showMessage(`List "${name}" created successfully!`, 'success');
                hideModal(createListModal);
                listNameInput.value = '';
            }).catch(error => {
                console.error("Error creating list:", error);
                showMessage("Failed to create list.", 'error');
            }).finally(() => {
                hideLoading();
            });

        }
        function changeCurrentListEmoji() {
            if (!currentUserId || !currentListId) return;

            const baseLabel = stripLeadingEmoji(currentListName || '').trim();
            const suggested = getListEmoji(currentListName || '');
            const input = prompt('Enter an emoji for this list (leave empty to auto-pick):', suggested);

            if (input === null) return; // user cancelled

            let emoji = '';
            const val = (input || '').trim();
            if (val === '') {
                emoji = getListEmoji(baseLabel);
            } else {
                const m = val.match(/^(\p{Emoji_Presentation}|\p{Extended_Pictographic})/u);
                if (!m) {
                    showMessage('Please enter a valid emoji.', 'error');
                    return;
                }
                emoji = m[1];
            }

            const newName = `${emoji} ${baseLabel}`.trim();
            showLoading();
            db.ref(`users/${currentUserId}/lists/${currentListId}`)
                .update({ name: newName })
                .then(() => {
                    currentListName = newName;
                    showMessage('List emoji updated!', 'success');
                })
                .catch(err => {
                    console.error('Error updating emoji:', err);
                    showMessage('Failed to update emoji.', 'error');
                })
                .finally(() => hideLoading());
        }








        function deleteCurrentList() {
            if (!currentUserId || !currentListId) return;

            // Prevent deleting the last list
            if (listsContainer.children.length <= 1) {
                showMessage("You cannot delete the last list. Create another one first if you wish to delete this one.", 'error', 5000);
                hideModal(confirmDeleteModal);
                return;
            }

            confirmDeleteMessage.textContent = `Are you sure you want to delete the list "${currentListName}" and all its videos? This action cannot be undone.`;
            showModal(confirmDeleteModal);
            confirmDeleteBtn.onclick = () => {
                showLoading();
                db.ref(`users/${currentUserId}/lists/${currentListId}`).remove()
                    .then(() => {
                        showMessage(`List "${currentListName}" deleted.`, 'success');
                        hideModal(confirmDeleteModal);
                        // The list listener will automatically re-render and select a new list
                    })
                    .catch(error => {
                        console.error("Error deleting list:", error);
                        showMessage("Failed to delete list.", 'error');
                    })
                    .finally(() => {
                        hideLoading();
                    });
            };
        }

        // NEW: Archive flow
        function openConfirmArchiveModal() {
            if (!currentListId || !currentListName) {
                showMessage("No list selected to archive.", 'error');
                return;
            }
            confirmArchiveMessage.textContent = `Archive the list "${currentListName}"? You can view it later from Archived Lists.`;
            showModal(confirmArchiveModal);
            confirmArchiveBtn.onclick = () => {
                archiveCurrentList();
            };
        }

        function archiveCurrentList() {
            if (!currentUserId || !currentListId) return;
            showLoading();
            db.ref(`users/${currentUserId}/lists/${currentListId}`).update({
                isArchived: true,
                archivedAt: firebase.database.ServerValue.TIMESTAMP
            }).then(() => {
                showMessage(`List "${currentListName}" archived.`, 'success');
                hideModal(confirmArchiveModal);
                // Selection reset; loadLists listener will re-render
                currentListId = null;
                currentListName = null;
            }).catch(err => {
                console.error('Error archiving list:', err);
                showMessage('Failed to archive list.', 'error');
            }).finally(() => hideLoading());
        }

        function openArchivedListsModal() {
            renderArchivedListsModal(); // ensure fresh view
            showModal(archivedListsModal);
        }
        function renderArchivedListsModal() {
            function unarchiveListById(listId, listName) {
                if (!currentUserId || !listId) return;
                showLoading();
                db.ref(`users/${currentUserId}/lists/${listId}`)
                    .update({ isArchived: false, archivedAt: null })
                    .then(() => {
                        showMessage(`List "${stripLeadingEmoji(listName)}" unarchived.`, 'success');
                        // Local UI turant refresh ke liye array se hata dein
                        archivedLists = archivedLists.filter(l => l.id !== listId);
                        renderArchivedListsModal();
                    })
                    .catch(err => {
                        console.error('Error unarchiving list:', err);
                        showMessage('Failed to unarchive list.', 'error');
                    })
                    .finally(() => hideLoading());
            }

            function deleteArchivedListById(listId, listName) {
                if (!currentUserId || !listId) return;
                confirmDeleteMessage.textContent = `Delete archived list "${stripLeadingEmoji(listName)}" and all its videos? This cannot be undone.`;
                showModal(confirmDeleteModal);
                confirmDeleteBtn.onclick = () => {
                    showLoading();
                    db.ref(`users/${currentUserId}/lists/${listId}`).remove()
                        .then(() => {
                            showMessage('Archived list deleted.', 'success');
                            hideModal(confirmDeleteModal);
                            // Local UI update
                            archivedLists = archivedLists.filter(l => l.id !== listId);
                            renderArchivedListsModal();
                        })
                        .catch(err => {
                            console.error('Error deleting archived list:', err);
                            showMessage('Failed to delete archived list.', 'error');
                        })
                        .finally(() => hideLoading());
                };
            }

            archivedListsContainer.innerHTML = '';
            if (!archivedLists || archivedLists.length === 0) {
                archivedListsContainer.innerHTML = '<p style="color:var(--text-muted-color);">No archived lists.</p>';
                return;
            }

            const list = document.createElement('div');
            archivedLists.forEach(({ id, name }) => {
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.gap = '10px';
                row.style.padding = '8px 0';
                row.dataset.id = id;
                row.dataset.name = name || '';

                const emojiEl = document.createElement('span');
                emojiEl.className = 'list-emoji';
                emojiEl.textContent = getListEmoji(name || '');
                const label = document.createElement('span');
                label.className = 'list-label';
                label.style.flex = '1';
                label.textContent = stripLeadingEmoji(name || '(untitled)');

                const openBtn = document.createElement('button');
                openBtn.textContent = 'Open';
                openBtn.dataset.act = 'open';

                const unarchiveBtn = document.createElement('button');
                unarchiveBtn.className = 'outline';
                unarchiveBtn.textContent = 'Unarchive';
                unarchiveBtn.dataset.act = 'unarchive';

                const delBtn = document.createElement('button');
                delBtn.className = 'danger';
                delBtn.textContent = 'Delete';
                delBtn.dataset.act = 'delete';

                row.appendChild(emojiEl);
                row.appendChild(label);
                row.appendChild(openBtn);
                row.appendChild(unarchiveBtn);
                row.appendChild(delBtn);
                list.appendChild(row);
            });

            archivedListsContainer.appendChild(list);

            // Delegate clicks for Open/Unarchive/Delete
            archivedListsContainer.onclick = (e) => {
                const actBtn = e.target.closest('button');
                if (!actBtn) return;
                const row = actBtn.closest('div');
                const id = row?.dataset.id;
                const name = row?.dataset.name || '';
                if (!id) return;


                if (actBtn.dataset.act === 'open') {
                    window.openArchivedListInSidebar(id, name);
                    hideModal(archivedListsModal); // <— yeh nayi line modal ko band kar degi
                } else if (actBtn.dataset.act === 'unarchive') {
                    unarchiveListById(id, name);
                } else if (actBtn.dataset.act === 'delete') {
                    deleteArchivedListById(id, name);
                }


            };

        }
        // === Temporary Archived List Helpers ===
        window.openArchivedListInSidebar = function (listId, listName) {
            if (!currentUserId || !listId) return;

            // agar koi aur temp laga hua hai aur different hai to pehle hata dein
            if (tempArchivedListId && tempArchivedListId !== listId) {
                removeTempArchivedFromSidebar();
            }
            tempArchivedListId = listId;
            tempArchivedListName = listName || '';

            injectTempArchivedListIntoSidebar();
            // list ko select karo (DB me isArchived flag same rahega)
            selectList(tempArchivedListId, tempArchivedListName);
            showMessage(`Opened archived list "${stripLeadingEmoji(tempArchivedListName)}" temporarily.`, 'success', 2500);
        };

        function injectTempArchivedListIntoSidebar() {
            if (!tempArchivedListId) return;

            // agar already exist karta hai to bas class ensure karo
            const exists = listsContainer.querySelector(`.list-item[data-id="${tempArchivedListId}"]`);
            if (exists) {
                exists.classList.add('temp-archived');
                return;
            }

            const btn = document.createElement('button');
            btn.className = 'list-item temp-archived';
            btn.setAttribute('data-id', tempArchivedListId);

            const emoji = document.createElement('span');
            emoji.className = 'list-emoji';
            emoji.textContent = getListEmoji(tempArchivedListName || '');

            const handle = document.createElement('span');
            handle.className = 'list-drag-handle';
            handle.title = 'Drag to reorder';
            handle.textContent = '⋮⋮';
            handle.style.display = 'none'; // temp item draggable nahi

            const label = document.createElement('span');
            label.className = 'list-label';
            label.textContent = stripLeadingEmoji(tempArchivedListName || '(untitled)');

            const right = document.createElement('div');
            right.className = 'list-actions-right';
            // temp item ke liye koi kebab/menu nahi

            btn.appendChild(emoji);
            btn.appendChild(handle);
            btn.appendChild(label);
            btn.appendChild(right);

            btn.addEventListener('click', () => selectList(tempArchivedListId, tempArchivedListName));

            // sidebar ke top pe insert
            listsContainer.prepend(btn);
            updateActiveListClass(tempArchivedListId);
        }

        function removeTempArchivedFromSidebar() {
            const tempNode = listsContainer.querySelector('.list-item.temp-archived');
            if (tempNode) tempNode.remove();
            tempArchivedListId = null;
            tempArchivedListName = null;
        }


        // Function to open rename modal (New)
        function openRenameListModal() {
            if (!currentListId || !currentListName) {
                showMessage("No list selected to rename.", 'error');
                return;
            }
            renameListNameInput.value = currentListName; // Pre-fill with current name
            showModal(renameListModal);
            renameListNameInput.focus();
        }

        // Function to submit rename (New)
        function renameCurrentList() {
            if (!currentUserId || !currentListId) return;
            const newName = renameListNameInput.value.trim();
            if (!newName) {
                showMessage("List name cannot be empty.", 'error');
                return;
            }
            if (newName === currentListName) {
                showMessage("New name is the same as the old name.", 'info');
                hideModal(renameListModal);
                return;
            }

            showLoading();
            db.ref(`users/${currentUserId}/lists/${currentListId}`).update({ name: newName })
                .then(() => {
                    showMessage(`List renamed to "${newName}" successfully!`, 'success');
                    currentListName = newName; // Update local state
                    hideModal(renameListModal);
                })
                .catch(error => {
                    console.error("Error renaming list:", error);
                    showMessage("Failed to rename list.", 'error');
                }).finally(() => {
                    hideLoading();
                });
        }

        function updateDeleteListButtonVisibility() {
            /* managed by list menu now */
        }

        // --- Video Management & API Calls ---
        // Robust extractor for drag data set in dragstart above
        function safeParseDragData(e) {
            try {
                // 1) Prefer our custom MIME
                const custom = e.dataTransfer.getData('application/x-yto-video');
                if (custom) return JSON.parse(custom);
            } catch { }

            try {
                // 2) Fallback: text/plain with our marker
                const txt = e.dataTransfer.getData('text/plain') || '';
                if (txt.startsWith('YTO:')) {
                    return JSON.parse(txt.slice(4));
                }
                // 3) Last resort: extract {...} substring only (in case text/plain has extra text)
                const start = txt.indexOf('{');
                const end = txt.lastIndexOf('}');
                if (start !== -1 && end !== -1 && end > start) {
                    const maybeJson = txt.slice(start, end + 1);
                    return JSON.parse(maybeJson);
                }
            } catch { }

            return null; // unable to parse safely
        }


        // Move a video document from one list to another
        async function moveVideoBetweenLists(videoId, fromListId, toListId) {
            showLoading();
            try {
                const fromRef = db.ref(`users/${currentUserId}/lists/${fromListId}/videos/${videoId}`);
                const snap = await fromRef.once('value');
                if (!snap.exists()) throw new Error('Source video not found.');

                const data = snap.val() || {};
                // Ensure order puts it at top of target list
                const orderTop = 0;
                // Option 1: keep same key (videoId) to avoid duplicates
                const toRef = db.ref(`users/${currentUserId}/lists/${toListId}/videos/${videoId}`);

                // Normalize fields as needed
                const movedData = {
                    ...data,
                    order: orderTop,
                    timestamp: data.timestamp || firebase.database.ServerValue.TIMESTAMP
                };

                // Write to target, then remove from source
                await toRef.set(movedData);
                await fromRef.remove();

                // Re-index target list orders so new one sits at top (optional nice-to-have)
                const targetVideosRef = db.ref(`users/${currentUserId}/lists/${toListId}/videos`);
                const targetSnap = await targetVideosRef.orderByChild('order').once('value');
                const updates = {};
                let idx = 0;
                targetSnap.forEach(child => {
                    updates[child.key + '/order'] = idx++;
                });
                await targetVideosRef.update(updates);

            } finally {
                hideLoading();
            }
        }

        // Cache for channel thumbnails to reduce API calls
        const channelThumbnailCache = {};

        // Utility to convert ISO 8601 duration (e.g., PT1H30M5S) to HH:MM:SS or MM:SS
        function formatDuration(isoDuration) {
            if (!isoDuration) return '';
            const regex = /PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/;
            const matches = isoDuration.match(regex);
            let hours = parseInt(matches[1] || 0);
            let minutes = parseInt(matches[2] || 0);
            let seconds = parseInt(matches[3] || 0);

            if (hours > 0) {
                return `${hours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            } else {
                return `${minutes}:${String(seconds).padStart(2, '0')}`;
            }
        }

        // Utility to format views (e.g., 354500 to 354.5K)
        function formatCount(count) {
            if (typeof count !== 'number') count = parseInt(count);
            if (isNaN(count)) return 'N/A';

            if (count >= 1000000000) return (count / 1000000000).toFixed(1) + 'B';
            if (count >= 1000000) return (count / 1000000).toFixed(1) + 'M';
            if (count >= 1000) return (count / 1000).toFixed(1) + 'K';
            return count.toLocaleString();
        }

        // Utility to format time ago (e.g., "3 days ago")
        function timeAgo(dateString) {
            if (!dateString) return 'N/A';
            const date = new Date(dateString);
            const now = new Date();
            const seconds = Math.floor((now - date) / 1000);

            const units = [
                { s: 31536000, name: 'year' },
                { s: 2592000, name: 'month' },
                { s: 86400, name: 'day' },
                { s: 3600, name: 'hour' },
                { s: 60, name: 'minute' }
            ];
            for (const u of units) {
                const n = Math.floor(seconds / u.s);
                if (n >= 1) return n + ' ' + u.name + (n === 1 ? ' ago' : 's ago');
            }
            const n = Math.floor(seconds);
            return n + ' second' + (n === 1 ? ' ago' : 's ago');
        }


        async function getChannelThumbnail(channelId) {
            if (channelThumbnailCache[channelId]) {
                return channelThumbnailCache[channelId];
            }

            const cachedThumbnail = await db.ref(`channelThumbnails/${channelId}`).once('value');
            if (cachedThumbnail.exists() && cachedThumbnail.val().url) {
                channelThumbnailCache[channelId] = cachedThumbnail.val().url;
                return cachedThumbnail.val().url;
            }

            try {
                const response = await fetch(`https://www.googleapis.com/youtube/v3/channels?part=snippet&id=${channelId}&key=${YOUTUBE_API_KEY}`);
                const data = await response.json();

                if (!response.ok || data.items.length === 0 || !data.items[0].snippet || !data.items[0].snippet.thumbnails || !data.items[0].snippet.thumbnails.default) {
                    console.warn(`Could not get channel thumbnail for ${channelId}:`, data.error ? data.error.message : 'No items found or no default thumbnail.');
                    return '';
                }
                const thumbnailUrl = data.items[0].snippet.thumbnails.default.url;
                channelThumbnailCache[channelId] = thumbnailUrl;
                db.ref(`channelThumbnails/${channelId}`).set({ url: thumbnailUrl, fetchedAt: firebase.database.ServerValue.TIMESTAMP });
                return thumbnailUrl;
            } catch (error) {
                console.error("Error fetching channel thumbnail:", error);
                return '';
            }
        }


        async function getVideoDetails(youtubeUrl) {
            try {
                const videoIdMatch = youtubeUrl.match(/(?:https?:\/\/)?(?:www\.)?(?:m\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=|embed\/|v\/|)([\w-]{11})(?:\S+)?/);
                if (!videoIdMatch || !videoIdMatch[1]) {
                    throw new Error('Invalid YouTube URL provided.');
                }
                const videoId = videoIdMatch[1];

                // Check if video already exists in current list
                if (currentListId && currentUserId) {
                    const videoExists = await db.ref(`users/${currentUserId}/lists/${currentListId}/videos`).orderByChild('youtubeId').equalTo(videoId).once('value');
                    if (videoExists.exists()) {
                        throw new Error('This video already exists in the current list.');
                    }
                }

                const videoResponse = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics,contentDetails&id=${videoId}&key=${YOUTUBE_API_KEY}`);
                const videoData = await videoResponse.json();

                if (!videoResponse.ok || videoData.items.length === 0) {
                    const errorMessage = videoData.error ? videoData.error.message : `Could not find video for ID: ${videoId}`;
                    console.error("YouTube API Error:", videoData.error);
                    throw new Error(`YouTube API Error: ${errorMessage}. Check your YouTube API Key and ensure "YouTube Data API v3" is enabled in your Google Cloud project.`);
                }

                const video = videoData.items[0];
                const snippet = video.snippet;
                const statistics = video.statistics;
                const contentDetails = video.contentDetails;

                const channelId = snippet.channelId;
                const channelThumbnail = await getChannelThumbnail(channelId);

                let subscriberCount = 'N/A';
                try {
                    const channelStatsResponse = await fetch(`https://www.googleapis.com/youtube/v3/channels?part=statistics&id=${channelId}&key=${YOUTUBE_API_KEY}`);
                    const channelStatsData = await channelStatsResponse.json();
                    if (channelStatsResponse.ok && channelStatsData.items.length > 0 && channelStatsData.items[0].statistics && channelStatsData.items[0].statistics.subscriberCount) {
                        subscriberCount = formatCount(parseInt(channelStatsData.items[0].statistics.subscriberCount));
                    }
                } catch (channelError) {
                    console.warn("Error fetching channel statistics for subscriber count:", channelError);
                }

                return {
                    youtubeId: videoId,
                    title: snippet.title,
                    thumbnail: snippet.thumbnails.high ? snippet.thumbnails.high.url : snippet.thumbnails.default.url,
                    views: formatCount(statistics.viewCount),
                    channelName: snippet.channelTitle,
                    channelThumbnailUrl: channelThumbnail,
                    duration: formatDuration(contentDetails.duration),
                    publishedAt: snippet.publishedAt,
                    subscribers: subscriberCount
                };

            } catch (error) {
                console.error("Error fetching video details:", error);
                throw error; // Re-throw to be caught by the caller
            }
        }

        async function addVideo(videoLink) {
            if (!videoLink) {
                showMessage("Please enter a YouTube video URL.", 'error');
                return;
            }

            if (!currentUserId || !currentListId) {
                showMessage("No list selected or user not authenticated. Please wait or create a list first.", 'error');
                return;
            }

            showLoading();
            try {
                const videoDetails = await getVideoDetails(videoLink);
                if (!videoDetails) { // Should not happen if getVideoDetails throws on error
                    showMessage("Failed to retrieve video details.", 'error');
                    return;
                }

                const newVideoRef = db.ref(`users/${currentUserId}/lists/${currentListId}/videos`).push();
                newVideoRef.set({
                    ...videoDetails,
                    order: -(new Date().getTime()), // Using negative timestamp for initial top sorting
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                }).then(() => {
                    showMessage("Video added successfully! You can drag it to reorder.", 'success', 4000);
                }).catch(error => {
                    console.error("Error adding video to database:", error);
                    showMessage("Failed to add video to database.", 'error');
                }).finally(() => {
                    hideLoading();
                });
            } catch (error) {
                showMessage(`Error adding video: ${error.message}`, 'error', 5000);
            } finally {
                hideLoading();
            }
        }


        function renderVideos() {
            if (!currentUserId || !currentListId) {
                videoGridContainer.innerHTML = '<p style="text-align: center; color: var(--text-color); grid-column: 1 / -1;">Select or create a list to start adding videos.</p>';
                return;
            }

            videoGridContainer.innerHTML = ''; // Clear existing cards
            videoCards = {}; // Reset local cache of video cards
            if (sortableInstance) {
                sortableInstance.destroy();
                sortableInstance = null;
            }
            if (videoListenerRef) {
                videoListenerRef.off('value'); // Detach old listener
            }

            showLoading();
            const currentVideosRef = db.ref(`users/${currentUserId}/lists/${currentListId}/videos`);
            videoListenerRef = currentVideosRef;

            currentVideosRef.orderByChild('order').on('value', snapshot => {
                // Clear all children. All videos will be re-added below.
                Array.from(videoGridContainer.children).forEach(child => {
                    child.remove();
                });
                videoCards = {}; // Reset for fresh render

                const videos = [];
                snapshot.forEach(childSnapshot => {
                    const data = childSnapshot.val();
                    // Ensure 'order' field exists, assign a default negative timestamp if not
                    if (typeof data.order !== 'number' || data.order === null) {
                        data.order = data.timestamp ? -(new Date(data.timestamp).getTime()) : -(Date.now());
                        childSnapshot.ref.update({ order: data.order }); // Update Firebase
                    }
                    videos.push({ id: childSnapshot.key, ...data });
                });

                if (videos.length > 0) {
                    // Sorting is handled by Firebase orderByChild, but client-side sort for safety
                    videos.sort((a, b) => a.order - b.order);

                    videos.forEach(video => {
                        const cardElement = createVideoCardElement(video.id, video);
                        videoGridContainer.appendChild(cardElement);
                        videoCards[video.id] = {
                            element: cardElement,
                            data: video
                        };
                    });
                } else {
                    const noVideosP = document.createElement('p');
                    noVideosP.style.cssText = 'text-align: center; color: var(--text-color); grid-column: 1 / -1;';
                    noVideosP.textContent = 'No videos in this list yet. Click "Add Video" in the header to get started!';
                    videoGridContainer.appendChild(noVideosP);
                }
                initializeSortable();
                hideLoading();
                // Apply search filter if active
                if (searchInput.value.trim() !== '') {
                    triggerSearch();
                }
            }, error => {
                console.error("Error loading videos:", error);
                showMessage("Failed to load videos for this list.", 'error');
                hideLoading();
            });
        }

        function createVideoCardElement(videoId, videoData) {
            const card = document.createElement('div');
            // Enable native drag to drop onto sidebar lists
            card.setAttribute('draggable', 'true');

            card.addEventListener('dragstart', (e) => {
                const payload = { videoId, fromListId: currentListId };
                const json = JSON.stringify(payload);

                // Save for browsers that hide dataTransfer during dragover
                currentDragPayload = payload;
                isDraggingVideo = true;

                e.dataTransfer.setData('application/x-yto-video', json);
                e.dataTransfer.setData('text/plain', 'YTO:' + json);
                e.dataTransfer.effectAllowed = 'move';

                document.body.classList.add('dragging-video');
                card.style.opacity = '0.6';
            });

            card.addEventListener('dragend', () => {
                isDraggingVideo = false;
                currentDragPayload = null;

                document.body.classList.remove('dragging-video');
                card.style.opacity = '';
                document.querySelectorAll('.list-item.drop-hover').forEach(el => el.classList.remove('drop-hover'));
            });

            card.classList.add('video-card');
            card.setAttribute('data-id', videoId);
            card.setAttribute('data-title', (videoData.title || '').toLowerCase());
            card.setAttribute('data-channel', (videoData.channelName || '').toLowerCase());
            card.setAttribute('data-link', `https://www.youtube.com/watch?v=${videoData.youtubeId}`);

            const uploadedTime = videoData.publishedAt ? timeAgo(videoData.publishedAt) : 'N/A';
            const viewsText = videoData.views ? `${videoData.views} views` : 'N/A views';
            const subscribersText = videoData.subscribers ? `${videoData.subscribers} subs` : 'N/A subs';
            const channelAvatarSrc = videoData.channelThumbnailUrl || '';
            const hideAvatar = channelAvatarSrc === '' ? 'style="display:none;"' : '';

            const hasNote = videoData.note && videoData.note.trim() !== '';
            const noteButtonClass = hasNote ? 'open-note' : 'add-note';

            // Add 'has-note' class to the main card if a note exists for CSS visibility logic
            if (hasNote) {
                card.classList.add('has-note');
            }

            card.innerHTML = `
                <div class="video-card-thumbnail">
                    <img src="${videoData.thumbnail}" alt="${videoData.title} thumbnail">
                    <span class="duration-overlay">${videoData.duration || ''}</span>
                    
                    <!-- Action buttons (Note & Three Dots) are now INSIDE thumbnail for positioning -->
                    <div class="video-card-action-buttons">
<button class="inline-note-btn ${noteButtonClass}" data-id="${videoId}" title="${hasNote ? 'Open Note' : 'Add Note'}" aria-label="${hasNote ? 'Open note' : 'Add note'}">&#x1F4DD;</button>
<button class="three-dots-menu-btn" title="More options" aria-label="More options">...</button>
                    </div>
                </div>
<div class="video-card-info-wrapper" id="video-info-${videoId}">
                    <img class="channel-avatar" src="${channelAvatarSrc}" alt="${videoData.channelName} avatar" ${hideAvatar}>
                    <div class="video-text-content">
                        <h3>${videoData.title}</h3>
                        <div class="video-card-meta">
                            <p class="channel-name">${videoData.channelName}</p>
                            <p>${viewsText} • ${subscribersText} • ${uploadedTime}</p>
                        </div>
                    </div>
                    <!-- video-menu-overlay remains here, it's displayed as a fixed overlay -->
                    <div class="video-menu-overlay">
                        <button class="menu-item view-btn" data-videoid="${videoData.youtubeId}">View Video</button>
                        <button class="menu-item delete-btn danger" data-id="${videoId}">Delete</button>
                    </div>
                </div>
            `;

            // Open video on thumbnail click (excluding clicks on action buttons themselves)
            card.querySelector('.video-card-thumbnail').addEventListener('click', (e) => {
                // Prevent opening video if click originated from action buttons
                if (e.target.closest('.video-card-action-buttons')) {
                    return;
                }
                const w = window.open(`https://www.youtube.com/watch?v=${videoData.youtubeId}`, '_blank', 'noopener');
                if (w) w.opener = null;
            });


            const menuButton = card.querySelector('.three-dots-menu-btn');
            const menuOverlay = card.querySelector('.video-menu-overlay');

            if (menuButton && menuOverlay) {
                menuButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Close any other open menu
                    if (currentMenu && currentMenu !== menuOverlay) {
                        currentMenu.classList.remove('active');
                        // When detaching, return menu to its original parent
                        const previousParent = currentMenu.dataset.originalParentId ? document.getElementById(currentMenu.dataset.originalParentId) : null;
                        if (previousParent) {
                            previousParent.appendChild(currentMenu);
                            currentMenu.removeAttribute('data-original-parent-id');
                        }
                    }

                    // Position the menu
                    const rect = menuButton.getBoundingClientRect();
                    // Calculate position relative to the viewport
                    let menuLeft = rect.left;
                    let menuTop = rect.bottom + 5;

                    // Ensure menu doesn't go off screen to the right
                    if (menuLeft + menuOverlay.offsetWidth > window.innerWidth - 10) {
                        menuLeft = window.innerWidth - menuOverlay.offsetWidth - 10;
                    }
                    // Ensure menu doesn't go off screen to the left
                    if (menuLeft < 10) {
                        menuLeft = 10;
                    }

                    // Ensure menu doesn't go off screen to the bottom
                    if (menuTop + menuOverlay.offsetHeight > window.innerHeight - 10) {
                        // Try to open upwards if space below is insufficient
                        menuTop = rect.top - menuOverlay.offsetHeight - 5;
                        // If still not enough space, or if it goes off top, fallback to 10px from top
                        if (menuTop < 10) {
                            menuTop = 10;
                        }
                    }

                    menuOverlay.style.top = `${menuTop}px`;
                    menuOverlay.style.left = `${menuLeft}px`;

                    // Temporarily append to body to ensure it's on top and not cut off by card overflow
                    const infoWrapper = card.querySelector('.video-card-info-wrapper');
                    menuOverlay.dataset.originalParentId = infoWrapper ? infoWrapper.id : '';
                    document.body.appendChild(menuOverlay);
                    menuOverlay.classList.toggle('active');
                    currentMenu = menuOverlay.classList.contains('active') ? menuOverlay : null;
                });
            }

            card.querySelector('.view-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                if (currentMenu) {
                    currentMenu.classList.remove('active');
                    const previousParent = currentMenu.dataset.originalParentId ? document.getElementById(currentMenu.dataset.originalParentId) : null;
                    if (previousParent) { previousParent.appendChild(currentMenu); currentMenu.removeAttribute('data-original-parent-id'); }
                }
                const w2 = window.open(`https://www.youtube.com/watch?v=${e.target.dataset.videoid}`, '_blank', 'noopener');
                if (w2) w2.opener = null;
            });

            card.querySelector('.delete-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                if (currentMenu) {
                    currentMenu.classList.remove('active');
                    const previousParent = currentMenu.dataset.originalParentId ? document.getElementById(currentMenu.dataset.originalParentId) : null;
                    if (previousParent) { previousParent.appendChild(currentMenu); currentMenu.removeAttribute('data-original-parent-id'); }
                }
                // Set the video ID for confirmation
                const videoIdToDelete = e.target.dataset.id;
                confirmDeleteMessage.textContent = `Are you sure you want to delete "${videoData.title}"?`;
                showModal(confirmDeleteModal);
                confirmDeleteBtn.onclick = () => {
                    showLoading();
                    db.ref(`users/${currentUserId}/lists/${currentListId}/videos/${videoIdToDelete}`).remove()
                        .then(() => {
                            showMessage("Video deleted.", 'success');
                            hideModal(confirmDeleteModal);
                        })
                        .catch(error => {
                            console.error("Error deleting video:", error);
                            showMessage("Failed to delete video.", 'error');
                        }).finally(() => {
                            hideLoading();
                        });
                };
            });

            // --- New Note Functionality ---
            const inlineNoteBtn = card.querySelector('.inline-note-btn');
            if (inlineNoteBtn) {
                inlineNoteBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Stop click from propagating to thumbnail's open video event
                    openNoteEditModal(videoId);
                });
            }

            return card;
        }

        // --- Note Edit Modal Functions ---
        function openNoteEditModal(videoId) {
            if (!videoCards[videoId]) {
                showMessage("Video data not found.", 'error');
                return;
            }
            currentNoteVideoId = videoId;
            const video = videoCards[videoId].data;

            // Populate the video preview in the modal
            const uploadedTime = video.publishedAt ? timeAgo(video.publishedAt) : 'N/A';
            const viewsText = video.views ? `${video.views} views` : 'N/A views';

            noteVideoDetails.innerHTML = `
                <div class="note-modal-video-preview-thumbnail">
                    <img src="${video.thumbnail}" alt="${video.title} thumbnail">
                    <span class="duration-overlay">${video.duration || ''}</span>
                </div>
                <div class="note-modal-video-preview-info">
                    <h3>${video.title}</h3>
                    <p>${video.channelName}</p>
                    <p>${viewsText} • ${uploadedTime}</p>
                </div>
            `;
            noteModalTitle.textContent = "Edit Note"; // Generic title, video info is in preview

            noteTextareaModal.value = video.note || '';

            if (video.note && video.note.trim() !== '') {
                deleteNoteBtnModal.style.display = 'inline-block';
            } else {
                deleteNoteBtnModal.style.display = 'none';
            }
            showModal(noteEditModal);
            noteTextareaModal.focus(); // Focus on textarea when modal opens
        }

        function saveNoteFromModal() {
            if (!currentUserId || !currentListId || !currentNoteVideoId) {
                showMessage("Error: Missing data to save note.", 'error');
                return;
            }
            showLoading();
            const noteContent = noteTextareaModal.value.trim();
            db.ref(`users/${currentUserId}/lists/${currentListId}/videos/${currentNoteVideoId}/note`).set(noteContent === '' ? null : noteContent)
                .then(() => {
                    if (videoCards[currentNoteVideoId]) {
                        videoCards[currentNoteVideoId].data.note = noteContent; // Update local data
                        updateInlineNoteButton(currentNoteVideoId); // Update the card's note button and its parent .has-note class
                    }
                    showMessage("Note saved!", 'success', 1500);
                    hideModal(noteEditModal);
                }).catch(error => {
                    console.error("Error saving note:", error);
                    showMessage("Failed to save note.", 'error');
                }).finally(() => {
                    hideLoading();
                });
        }

        function deleteNoteFromModal() {
            if (!currentUserId || !currentListId || !currentNoteVideoId) {
                showMessage("Error: Missing data to delete note.", 'error');
                return;
            }
            // Add confirmation for delete note action
            confirmDeleteMessage.textContent = `Are you sure you want to delete the note for "${videoCards[currentNoteVideoId].data.title}"?`;
            showModal(confirmDeleteModal);
            confirmDeleteBtn.onclick = () => {
                showLoading();
                db.ref(`users/${currentUserId}/lists/${currentListId}/videos/${currentNoteVideoId}/note`).remove()
                    .then(() => {
                        if (videoCards[currentNoteVideoId]) {
                            videoCards[currentNoteVideoId].data.note = null; // Update local data
                            updateInlineNoteButton(currentNoteVideoId); // Update the card's note button and its parent .has-note class
                        }
                        showMessage("Note deleted!", 'success', 1500);
                        hideModal(noteEditModal); // Close note modal
                        hideModal(confirmDeleteModal); // Close confirm modal
                    }).catch(error => {
                        console.error("Error deleting note:", error);
                        showMessage("Failed to delete note.", 'error');
                    }).finally(() => {
                        hideLoading();
                    });
            };
        }

        function updateInlineNoteButton(videoId) {
            const cardElement = videoCards[videoId]?.element;
            if (!cardElement) return;

            const noteButton = cardElement.querySelector('.inline-note-btn');
            const hasNote = videoCards[videoId].data.note && videoCards[videoId].data.note.trim() !== '';

            // Update class on the note button itself
            if (noteButton) {
                noteButton.classList.remove('add-note', 'open-note');
                noteButton.classList.add(hasNote ? 'open-note' : 'add-note');
                noteButton.setAttribute('title', hasNote ? 'Open Note' : 'Add Note'); // Update title attribute
            }

            // Update 'has-note' class on the main video card
            // This is crucial for the visibility logic in CSS
            if (hasNote) {
                cardElement.classList.add('has-note');
            } else {
                cardElement.classList.remove('has-note');
            }
        }


        // --- Sortable.js Initialization and Update Logic ---

        function initListsSortable() {
            if (!listSortMode) {
                if (listsSortable) { listsSortable.destroy(); listsSortable = null; }
                return;
            }
            if (listsSortable) { listsSortable.destroy(); }

            listsSortable = Sortable.create(listsContainer, {
                animation: 150,
                draggable: '.list-item',
                handle: '.list-drag-handle',
                onUpdate: function () {
                    if (!currentUserId) return;
                    const ids = Array.from(listsContainer.querySelectorAll('.list-item'))
                        .filter(el => !el.classList.contains('temp-archived'))
                        .map(el => el.dataset.id);
                    const updates = {};
                    ids.forEach((id, idx) => { updates[`${id}/order`] = idx; });
                    db.ref(`users/${currentUserId}/lists`).update(updates).catch(err => {
                        console.error('Failed to update list order:', err);
                        showMessage('Failed to save list order.', 'error');
                    });
                }
            });
        }
        function toggleListReorder() {
            listSortMode = !listSortMode;
            // Toggle visual state
            listsContainer.classList.toggle('reorder-active', listSortMode);
            // (Re)initialize Sortable for lists
            initListsSortable();
            // Update the popover label text on all menus (so it flips to Done / Reorder)
            document.querySelectorAll('.list-actions-popover .menu-item[data-act="reorder"] span:last-child')
                .forEach(el => el.textContent = listSortMode ? 'Done Reordering' : 'Reorder Lists');
        }


        function initializeSortable() {
            if (sortableInstance) {
                sortableInstance.destroy();
            }

            sortableInstance = Sortable.create(videoGridContainer, {
                animation: 150,
                group: 'videos',
                draggable: '.video-card',
                handle: '.video-card-thumbnail', // Only thumbnail area is draggable handle
                filter: '.video-card-action-buttons', // Prevent dragging when clicking action buttons
                preventOnFilter: true, // Prevent the default drag and drop on filter elements

                onUpdate: function (evt) {
                    if (!currentUserId || !currentListId) {
                        showMessage("User not authenticated or no list selected. Cannot reorder.", 'error');
                        return;
                    }

                    const videoRefs = db.ref(`users/${currentUserId}/lists/${currentListId}/videos`);
                    const updates = {};

                    const newOrderIds = [];
                    Array.from(videoGridContainer.children).forEach(child => {
                        if (child.classList.contains('video-card')) {
                            newOrderIds.push(child.dataset.id);
                        }
                    });

                    // Assign new order values based on their current position
                    newOrderIds.forEach((id, index) => {
                        updates[id + '/order'] = index;
                    });

                    videoRefs.update(updates).then(() => {
                        console.log("Video order updated in Firebase.");
                        // The Firebase listener will re-render and sort
                    }).catch(error => {
                        console.error("Error updating video order:", error);
                        showMessage("Failed to update video order.", 'error');
                    });
                }
            });
        }


        // --- Search Functionality ---
        function triggerSearch() {
            const searchTerm = searchInput.value.toLowerCase().trim();
            for (const videoId in videoCards) {
                const card = videoCards[videoId].element;

                const title = card.dataset.title || '';
                const channel = card.dataset.channel || '';
                const link = card.dataset.link || '';

                if (title.includes(searchTerm) || channel.includes(searchTerm) || link.includes(searchTerm)) {
                    card.style.display = '';
                } else {
                    card.style.display = 'none';
                }
            }
            if (searchTerm === '') {
                // If search is cleared, ensure all cards are visible again
                Array.from(videoGridContainer.children).forEach(child => {
                    child.style.display = '';
                });
            }
        }
        searchInput.addEventListener('input', debounce(triggerSearch, 150));


        // --- Global Event Listeners ---

        // --- List actions menu (kebab) ---


        function closeAnyListMenus() {
            document.querySelectorAll('.list-actions-popover.active').forEach(el => el.classList.remove('active'));
        }
        document.addEventListener('click', (e) => {
            // close list popovers when clicking elsewhere
            if (!e.target.closest('.list-actions-popover') && !e.target.closest('.list-more-btn')) {
                closeAnyListMenus();
            }
        });

        // Close 3-dots menu if clicked outside
        document.addEventListener('click', (e) => {
            if (currentMenu && !e.target.closest('.video-menu-overlay') && !e.target.closest('.three-dots-menu-btn')) {
                currentMenu.classList.remove('active');
                // When detaching, return menu to its original parent
                const originalParentId = currentMenu.dataset.originalParentId;
                if (originalParentId) {
                    const previousParent = document.getElementById(originalParentId);
                    if (previousParent) {
                        previousParent.appendChild(currentMenu);
                        currentMenu.removeAttribute('data-original-parent-id');
                    }
                }
                currentMenu = null;
            }
        });


        // Modal close buttons (including the 'x' button)
        document.querySelectorAll('.cancel-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                hideModal(e.target.closest('.modal-overlay'));
            });
        });

        // Add Video button in header
        addVideoButtonHeader.addEventListener('click', () => {
            if (!currentUserId) {
                showMessage("Please sign in to add videos.", 'error');
                return;
            }
            videoLinkInput.value = ''; // Clear input on open
            showModal(addVideoModal);
            videoLinkInput.focus(); // Focus input for quick paste
        });

        // Submit video button in modal
        submitVideoBtn.addEventListener('click', () => {
            addVideo(videoLinkInput.value);
            hideModal(addVideoModal); // Hide after initiating add process
            videoLinkInput.value = ''; // Clear input
        });

        // Enter key for adding video
        videoLinkInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitVideoBtn.click();
            }
        });

        // Create List button
        createListBtn.addEventListener('click', () => {
            if (!currentUserId) {
                showMessage("Please sign in to create lists.", 'error');
                return;
            }
            listNameInput.value = ''; // Clear input on open
            showModal(createListModal);
            listNameInput.focus();
        });

        // Submit List button in modal
        submitListBtn.addEventListener('click', () => {
            const listName = listNameInput.value.trim();
            if (listName) {
                createNewList(listName);
            } else {
                showMessage("List name cannot be empty.", 'error');
            }
        });

        // Enter key for creating list
        listNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitListBtn.click();
            }
        });

        submitRenameListBtn.addEventListener('click', renameCurrentList);
        renameListNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitRenameListBtn.click();
            }
        });


        // Note modal buttons
        saveNoteBtnModal.addEventListener('click', saveNoteFromModal);
        noteTextareaModal.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) { // Ctrl+Enter or Cmd+Enter to save
                e.preventDefault();
                saveNoteFromModal();
            }
        });
        deleteNoteBtnModal.addEventListener('click', deleteNoteFromModal);


        let userPopover = null;

        function ensureUserPopover() {
            if (userPopover) return userPopover;
            userPopover = document.createElement('div');
            userPopover.className = 'user-popover';
            document.body.appendChild(userPopover);
            return userPopover;
        }
        function openUserPopover() {
            if (!currentUserId) return;
            const chipRect = authStatusSpan.getBoundingClientRect();
            const up = ensureUserPopover();
            const displayName = (auth.currentUser && (auth.currentUser.displayName || auth.currentUser.email)) || 'User';
            up.innerHTML = `
        <div class="name">${displayName}</div>
        <div class="row">UID: ${currentUserId}</div>
        <div class="actions">
            <button class="outline" id="logout-pop-btn">Logout</button>
        </div>
    `;
            const left = Math.min(Math.max(10, chipRect.left), window.innerWidth - 260);
            let top = chipRect.bottom + 8;
            if (top + 130 > window.innerHeight - 10) top = chipRect.top - 130 - 8;
            up.style.left = left + 'px';
            up.style.top = top + 'px';
            up.classList.add('active');
            up.querySelector('#logout-pop-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                closeUserPopover();
                signOutUser();
            }, { once: true });
        }
        function closeUserPopover() {
            if (userPopover) userPopover.classList.remove('active');
        }
        // Toggle on user chip click
        authStatusSpan.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!currentUserId) return;
            if (userPopover && userPopover.classList.contains('active')) {
                closeUserPopover();
            } else {
                openUserPopover();
            }
        });
        // Close when clicking outside
        document.addEventListener('click', (e) => {
            if (userPopover && userPopover.classList.contains('active') &&
                !e.target.closest('.user-popover') && !e.target.closest('#auth-status')) {
                closeUserPopover();
            }
        });


        // Event Listeners for NEW authentication buttons
        signInGoogleBtn.addEventListener('click', signInWithGoogle);
        archiveListsBtn.addEventListener('click', openArchivedListsModal);


        // --- Global Paste Listener (Ctrl+V functionality) ---
        document.body.addEventListener('paste', async (e) => {
            // Check if focus is on an input or textarea
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                return; // Let default paste handle it
            }

            const pastedText = (e.clipboardData || window.clipboardData).getData('text');
            const youtubeUrlRegex = /(?:https?:\/\/)?(?:www\.)?(?:m\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=|embed\/|v\/|)([\w-]{11})(?:\S+)?/i;

            if (youtubeUrlRegex.test(pastedText)) {
                e.preventDefault(); // Prevent default paste if it's a YouTube URL

                // Check if any modal is currently active
                const anyModalActive = document.querySelector('.modal-overlay.active');
                if (anyModalActive) {
                    showMessage("Please close the current popup before pasting a video link.", 'info', 3000);
                    return;
                }

                if (!currentListId) {
                    showMessage("Please select or create a list first to add videos.", 'error', 3000);
                    return;
                }

                // Fill the input and show the modal
                videoLinkInput.value = pastedText;
                showModal(addVideoModal);
                submitVideoBtn.focus(); // Focus the add button
            } else if (pastedText.trim() !== '') {
                // Optionally, show a message for non-YouTube URLs if desired, but user didn't ask for it
                // console.log("Pasted text is not a YouTube URL:", pastedText);
            }
        });


        // Initial render logic will be triggered by auth state change
    </script>
</body>

</html>
